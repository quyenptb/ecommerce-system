

/* ==========================================================================
   FILE: CustomerService.java
   PATH: customer-service\src\main\java\com\ecommerce\customer\application\service\CustomerService.java
   ========================================================================== */

package com.ecommerce.customer.application.service;

import com.ecommerce.customer.domain.model.Customer;
import com.ecommerce.customer.domain.repository.CustomerRepository;
import com.ecommerce.customer.event.CustomerCreatedEvent;
import com.ecommerce.customer.interfaces.rest.dto.CustomerDTO;
import com.ecommerce.customer.interfaces.rest.dto.CreateCustomerRequest;
import com.ecommerce.customer.interfaces.rest.dto.UpdateCustomerRequest;
import com.ecommerce.customer.domain.exception.CustomerNotFoundException;
import com.ecommerce.customer.domain.exception.DuplicateEmailException;
import com.ecommerce.customer.application.mapper.CustomerMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class CustomerService {
    
    private final CustomerRepository customerRepository;
    private final CustomerMapper customerMapper;
    private final PasswordEncoder passwordEncoder;
    private final ApplicationEventPublisher eventPublisher;
    
    @Transactional
    public CustomerDTO createCustomer(CreateCustomerRequest request) {
        log.info("Creating customer with email: {}", request.getEmail());
        
        if (customerRepository.existsByEmail(request.getEmail())) {
            throw new DuplicateEmailException("Email already exists: " + request.getEmail());
        }
        
        Customer customer = Customer.builder()
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword()))
                .firstName(request.getFirstName())
                .lastName(request.getLastName())
                .phone(request.getPhone())
                .address(request.getAddress())
                .isActive(true)
                .build();
        
        Customer savedCustomer = customerRepository.save(customer);
        
        // Publish domain event
        eventPublisher.publishEvent(new CustomerCreatedEvent(
                savedCustomer.getId(),
                savedCustomer.getEmail(),
                savedCustomer.getFirstName(),
                savedCustomer.getLastName(),
                LocalDateTime.now()
        ));
        
        log.info("Customer created successfully with id: {}", savedCustomer.getId());
        return customerMapper.toDTO(savedCustomer);
    }
    
    @Transactional(readOnly = true)
    public CustomerDTO getCustomer(UUID customerId) {
        log.debug("Fetching customer with id: {}", customerId);
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException(customerId));
        return customerMapper.toDTO(customer);
    }
    
    @Transactional
    public CustomerDTO updateCustomer(UUID customerId, UpdateCustomerRequest request) {
        log.info("Updating customer with id: {}", customerId);
        
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException(customerId));
        
        customerMapper.updateCustomerFromRequest(request, customer);
        Customer updatedCustomer = customerRepository.save(customer);
        
        log.info("Customer updated successfully with id: {}", customerId);
        return customerMapper.toDTO(updatedCustomer);
    }
    
    @Transactional
    public void deactivateCustomer(UUID customerId) {
        log.info("Deactivating customer with id: {}", customerId);
        
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new CustomerNotFoundException(customerId));
        
        customer.setActive(false);
        customerRepository.save(customer);
        
        log.info("Customer deactivated successfully with id: {}", customerId);
    }
    
    @Transactional(readOnly = true)
    public boolean validateCredentials(String email, String password) {
        return customerRepository.findActiveByEmail(email)
                .map(customer -> passwordEncoder.matches(password, customer.getPassword()))
                .orElse(false);
    }
}


/* ==========================================================================
   FILE: InventoryService.java
   PATH: inventory-service\src\main\java\com\ecommerce\inventory\application\service\InventoryService.java
   ========================================================================== */

package com.ecommerce.inventory.application.service;

import com.ecommerce.inventory.domain.model.Inventory;
import com.ecommerce.inventory.domain.repository.InventoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class InventoryService {

    private final InventoryRepository inventoryRepository;

    @Transactional(readOnly = true)
    public boolean isInStock(String sku) {
        return inventoryRepository.findBySku(sku)
                .map(inventory -> inventory.getStockStatus() == Inventory.StockStatus.IN_STOCK)
                .orElse(false);
    }

    @Transactional
    public void updateStock(UUID productId, int quantity) {
        Inventory inventory = inventoryRepository.findByProductId(productId)
                .orElseThrow(() -> new RuntimeException("Inventory not found for product: " + productId));
        
        inventory.updateStock(quantity);
        inventoryRepository.save(inventory);
        log.info("Updated stock for product {} to {}", productId, quantity);
    }
}


/* ==========================================================================
   FILE: NotificationService.java
   PATH: notification-service\src\main\java\com\ecommerce\notification\application\service\NotificationService.java
   ========================================================================== */

package com.ecommerce.notification.application.service;

import com.ecommerce.order.domain.model.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.UUID;

@Service
@Slf4j
public class NotificationService {

    public void sendWelcomeEmail(UUID customerId, String email, String fullName) {
        log.info("==================================================");
        log.info("SENDING WELCOME EMAIL");
        log.info("To: {} ({})", fullName, email);
        log.info("Subject: Welcome to Our E-commerce Platform!");
        log.info("Body: Dear {}, thank you for registering...", fullName);
        log.info("==================================================");
    }

    public void sendOrderConfirmation(UUID orderId, UUID customerId, BigDecimal amount) {
        log.info("==================================================");
        log.info("SENDING ORDER CONFIRMATION");
        log.info("Order ID: {}", orderId);
        log.info("Customer ID: {}", customerId);
        log.info("Total Amount: ${}", amount);
        log.info("==================================================");
    }

    public void sendOrderStatusUpdate(UUID orderId, Order.OrderStatus oldStatus, Order.OrderStatus newStatus) {
        log.info("==================================================");
        log.info("SENDING ORDER STATUS UPDATE");
        log.info("Order ID: {}", orderId);
        log.info("Status Change: {} -> {}", oldStatus, newStatus);
        log.info("==================================================");
    }
}


/* ==========================================================================
   FILE: OrderService.java
   PATH: order-service\src\main\java\com\ecommerce\order\application\service\OrderService.java
   ========================================================================== */

package com.ecommerce.order.application.service;


import com.ecommerce.order.application.event.OrderCreatedEvent;
import com.ecommerce.order.application.event.OrderStatusChangedEvent;
import com.ecommerce.order.domain.exception.OrderNotFoundException;
import com.ecommerce.order.domain.model.Order;
import com.ecommerce.order.domain.model.OrderItem;
import com.ecommerce.order.domain.repository.OrderRepository;
import com.ecommerce.order.interfaces.rest.dto.OrderDTO;
import com.ecommerce.order.application.mapper.OrderMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final OrderMapper orderMapper;
    private final ApplicationEventPublisher eventPublisher;
    
    @Transactional
    public OrderDTO createOrder(OrderCreatedEvent request) {
        log.info("Creating order for customer: {}", request.getCustomerId());
        
        Order order = Order.builder()
                .customerId(request.getCustomerId())
                .status(Order.OrderStatus.PENDING)
                .shippingAddress(request.getShippingAddress())
                .billingAddress(request.getBillingAddress())
                .build();
        
        request.getItems().forEach(itemRequest -> {
            OrderItem item = OrderItem.builder()
                    .productId(itemRequest.getProductId())
                    .sku(itemRequest.getSku())
                    .productName(itemRequest.getProductName())
                    .quantity(itemRequest.getQuantity())
                    .unitPrice(itemRequest.getUnitPrice())
                    .subtotal(itemRequest.getUnitPrice()
                            .multiply(BigDecimal.valueOf(itemRequest.getQuantity())))
                    .build();
            order.addItem(item);
        });
        
        order.calculateTotal();
        order.setPaymentDueDate(LocalDateTime.now().plusDays(2));
        
        Order savedOrder = orderRepository.save(order);
        
        // Publish domain event
        OrderCreatedEvent event = 
        OrderCreatedEvent.builder().id(savedOrder.getId()).customerId(savedOrder.getCustomerId()).totalAmount(savedOrder.getTotalAmount()).items(orderMapper.toOrderItemEvents(savedOrder.getItems())).build();
        
        
        eventPublisher.publishEvent(event);
        
        log.info("Order created successfully with id: {}", savedOrder.getId());
        return orderMapper.toDTO(savedOrder);
    }
    
    @Transactional(readOnly = true)
    public OrderDTO getOrder(UUID orderId) {
        log.debug("Fetching order with id: {}", orderId);
        Order order = orderRepository.findByIdWithItems(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));
        return orderMapper.toDTO(order);
    }
    
    @Transactional
    public OrderDTO updateOrderStatus(UUID orderId, Order.OrderStatus newStatus) {
        log.info("Updating order {} status to {}", orderId, newStatus);
        
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));
        
        Order.OrderStatus oldStatus = order.getStatus();
        order.setStatus(newStatus);
        Order updatedOrder = orderRepository.save(order);
        
        // Publish status change event
        eventPublisher.publishEvent(new OrderStatusChangedEvent(
                orderId,
                oldStatus,
                newStatus,
                LocalDateTime.now()
        ));
        
        log.info("Order {} status updated from {} to {}", 
                orderId, oldStatus, newStatus);
        return orderMapper.toDTO(updatedOrder);
    }
    
    @Transactional(readOnly = true)
    public List<OrderDTO> getCustomerOrders(UUID customerId) {
        log.debug("Fetching orders for customer: {}", customerId);
        return orderRepository.findByCustomerId(customerId).stream()
                .map(orderMapper::toDTO)
                .collect(Collectors.toList());
    }
}


/* ==========================================================================
   FILE: PaymentService.java
   PATH: payment-service\src\main\java\com\ecommerce\payment\application\service\PaymentService.java
   ========================================================================== */

package com.ecommerce.payment.application.service;

import com.ecommerce.payment.domain.model.Payment;
import com.ecommerce.payment.domain.repository.PaymentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

    private final PaymentRepository paymentRepository;

    @Transactional
    public void createPendingPayment(UUID orderId, UUID customerId, BigDecimal amount, LocalDateTime orderDate) {
        log.info("Creating pending payment for Order: {}", orderId);
        
        Payment payment = Payment.builder()
                .orderId(orderId)
                .customerId(customerId)
                .amount(amount)
                .status(Payment.PaymentStatus.PENDING)
                .build();

        paymentRepository.save(payment);
        log.info("Payment record created successfully.");
        
        // Mock processing payment immediately for demo purposes
        processPayment(payment);
    }

    private void processPayment(Payment payment) {
        // Logic giả lập thanh toán
        payment.setStatus(Payment.PaymentStatus.COMPLETED);
        paymentRepository.save(payment);
        log.info("Payment processed successfully for Order: {}", payment.getOrderId());
    }
}


/* ==========================================================================
   FILE: ProductService.java
   PATH: product-service\src\main\java\com\ecommerce\product\application\service\ProductService.java
   ========================================================================== */

package com.ecommerce.product.application.service;

import com.ecommerce.product.domain.model.Product;
import com.ecommerce.product.domain.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProductService {

    private final ProductRepository productRepository;

    // Cal by ProductEventConsumer
    @Transactional
    public void reserveStock(UUID productId, Integer quantity) {
        log.info("Attempting to reserve {} items for product {}", quantity, productId);
        
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("Product not found: " + productId));

        if (product.getStockQuantity() < quantity) {
            throw new RuntimeException("Insufficient stock for product: " + productId);
        }

        product.setStockQuantity(product.getStockQuantity() - quantity);
        productRepository.save(product);
        
        log.info("Stock reserved successfully. Remaining: {}", product.getStockQuantity());
    }
}
